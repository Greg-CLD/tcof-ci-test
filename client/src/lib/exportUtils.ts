import { getPlan, getParentsByStage, Stage, PlanRecord } from './plan-db';
import html2canvas from 'html2canvas';
import jsPDF from 'jspdf';
import { formatTaskName } from './taskDisplayName';

/**
 * Export a plan as a PDF document using plan ID
 * @param planId - The ID of the plan to export
 */
export const exportPlanPDF = async (planId: string): Promise<void> => {
  if (!planId) return;
  
  const plan = getPlan(planId);
  if (!plan) return;
  
  // Create a temporary div to render the content
  const tempDiv = document.createElement('div');
  tempDiv.className = 'pdf-export';
  tempDiv.style.padding = '40px';
  tempDiv.style.maxWidth = '800px';
  tempDiv.style.margin = '0 auto';
  tempDiv.style.backgroundColor = '#ffffff';
  tempDiv.style.color = '#000000';
  tempDiv.style.fontFamily = 'Arial, sans-serif';
  
  // Add title and header
  const title = document.createElement('h1');
  title.textContent = 'TCOF Project Plan Checklist';
  title.style.marginBottom = '20px';
  title.style.color = '#008080';
  title.style.fontSize = '24px';
  tempDiv.appendChild(title);
  
  // Add metadata
  const metadata = document.createElement('div');
  metadata.style.marginBottom = '30px';
  metadata.style.fontSize = '14px';
  metadata.innerHTML = `
    <p><strong>Generated:</strong> ${new Date().toLocaleString()}</p>
    <p><strong>Plan ID:</strong> ${planId}</p>
  `;
  tempDiv.appendChild(metadata);
  
  // Process the plan data
  const stages = ['Identification', 'Definition', 'Delivery', 'Closure'];
  const parentsByStage = getParentsByStage(planId);
  
  stages.forEach(stageStr => {
    const stage = stageStr as Stage;
    const stageSection = document.createElement('div');
    stageSection.style.marginBottom = '30px';
    
    const stageHeader = document.createElement('h2');
    stageHeader.textContent = stage;
    stageHeader.style.marginBottom = '15px';
    stageHeader.style.color = '#008080';
    stageHeader.style.fontSize = '20px';
    stageHeader.style.borderBottom = '2px solid #008080';
    stageHeader.style.paddingBottom = '5px';
    stageSection.appendChild(stageHeader);
    
    if (parentsByStage[stage] && parentsByStage[stage].length > 0) {
      const taskList = document.createElement('ul');
      taskList.style.paddingLeft = '20px';
      
      parentsByStage[stage].forEach((parent: any) => {
        if (parent.tasks && parent.tasks.length > 0) {
          const parentItem = document.createElement('li');
          parentItem.style.marginBottom = '10px';
          parentItem.style.fontWeight = 'bold';
          parentItem.textContent = parent.label;
          taskList.appendChild(parentItem);
          
          const subList = document.createElement('ul');
          subList.style.paddingLeft = '20px';
          subList.style.marginTop = '5px';
          
          parent.tasks.forEach((task: string) => {
            const taskItem = document.createElement('li');
            taskItem.style.marginBottom = '5px';
            taskItem.style.fontWeight = 'normal';
            taskItem.textContent = formatTaskName(task);
            subList.appendChild(taskItem);
          });
          
          parentItem.appendChild(subList);
        }
      });
      
      stageSection.appendChild(taskList);
    } else {
      const noTasks = document.createElement('p');
      noTasks.textContent = 'No tasks for this stage';
      noTasks.style.fontStyle = 'italic';
      noTasks.style.color = '#666666';
      stageSection.appendChild(noTasks);
    }
    
    tempDiv.appendChild(stageSection);
  });
  
  // Add footer
  const footer = document.createElement('div');
  footer.style.marginTop = '30px';
  footer.style.borderTop = '1px solid #cccccc';
  footer.style.paddingTop = '15px';
  footer.style.fontSize = '12px';
  footer.style.color = '#666666';
  footer.style.textAlign = 'center';
  footer.innerHTML = `
    <p>Generated by The Connected Outcomes Framework Toolkit</p>
    <p>Â© ${new Date().getFullYear()} Confluity Ltd. All rights reserved.</p>
  `;
  tempDiv.appendChild(footer);
  
  // Append to document temporarily (hidden)
  tempDiv.style.position = 'absolute';
  tempDiv.style.left = '-9999px';
  document.body.appendChild(tempDiv);
  
  try {
    // Convert to PDF
    const pdf = new jsPDF('p', 'mm', 'a4');
    const canvas = await html2canvas(tempDiv);
    const imgData = canvas.toDataURL('image/png');
    
    // Calculate dimensions
    const imgWidth = 210; // A4 width in mm
    const pageHeight = 295; // A4 height in mm
    const imgHeight = canvas.height * imgWidth / canvas.width;
    let heightLeft = imgHeight;
    let position = 0;
    
    // Add first page
    pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
    heightLeft -= pageHeight;
    
    // Add additional pages if content is too long
    while (heightLeft > 0) {
      position = heightLeft - imgHeight;
      pdf.addPage();
      pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
      heightLeft -= pageHeight;
    }
    
    // Save PDF
    pdf.save(`TCOF_Project_Plan_${planId}.pdf`);
  } catch (error) {
    console.error('Error generating PDF:', error);
  } finally {
    // Clean up
    document.body.removeChild(tempDiv);
  }
};

/**
 * Export the current plan as a CSV file
 * @param plan - The plan record to export
 * @returns The generated URL and filename
 */
export const exportCSV = (plan: PlanRecord): { url: string; filename: string } => {
  if (!plan) throw new Error('No plan provided');
  
  // Process the plan data
  const stages = ['Identification', 'Definition', 'Delivery', 'Closure'];
  const parentsByStage = getParentsByStage(plan.id);
  
  // Create CSV content
  let csvContent = 'Stage,Category,Task,Status\n';
  
  stages.forEach(stageStr => {
    const stage = stageStr as Stage;
    if (parentsByStage[stage] && parentsByStage[stage].length > 0) {
      parentsByStage[stage].forEach((parent: any) => {
        if (parent.tasks && parent.tasks.length > 0) {
          parent.tasks.forEach((task: string, index: number) => {
            // Format CSV row (escape commas in fields)
            const escapedCategory = `"${parent.label.replace(/"/g, '""')}"`;
            const escapedTask = `"${formatTaskName(task).replace(/"/g, '""')}"`;
            // Default to "Not Started" for status
            const status = '"Not Started"';
            csvContent += `${stage},${escapedCategory},${escapedTask},${status}\n`;
          });
        }
      });
    }
  });
  
  // Create the CSV file
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const filename = `TCOF_Project_Plan_${plan.id}.csv`;
  
  return { url, filename };
};

/**
 * Downloads a file using a URL
 * @param filename - The name to save the file as
 * @param url - The URL of the file
 */
export const downloadFile = (filename: string, url: string): void => {
  const link = document.createElement('a');
  link.setAttribute('href', url);
  link.setAttribute('download', filename);
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};

/**
 * Gets the Google Sheets import URL for a CSV file
 * @param url - The URL of the CSV file
 * @returns The Google Sheets import URL
 */
export const getGoogleSheetsImportUrl = (url: string): string => {
  // Google Sheets can't directly import from a blob URL
  // This would normally redirect to the Google Sheets import page
  return 'https://docs.google.com/spreadsheets/d/import';
};

/**
 * Exports the plan as a PDF document by rendering the element with the given ID
 * @param elementId - The ID of the HTML element to render as PDF
 */
export const exportPDF = async (elementId: string): Promise<void> => {
  const element = document.getElementById(elementId);
  if (!element) {
    throw new Error(`Element with ID "${elementId}" not found`);
  }
  
  try {
    // Convert to PDF
    const pdf = new jsPDF('p', 'mm', 'a4');
    const canvas = await html2canvas(element);
    const imgData = canvas.toDataURL('image/png');
    
    // Calculate dimensions
    const imgWidth = 210; // A4 width in mm
    const pageHeight = 295; // A4 height in mm
    const imgHeight = canvas.height * imgWidth / canvas.width;
    let heightLeft = imgHeight;
    let position = 0;
    
    // Add first page
    pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
    heightLeft -= pageHeight;
    
    // Add additional pages if content is too long
    while (heightLeft > 0) {
      position = heightLeft - imgHeight;
      pdf.addPage();
      pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
      heightLeft -= pageHeight;
    }
    
    // Save PDF
    pdf.save(`TCOF_Project_Checklist.pdf`);
  } catch (error) {
    console.error('Error generating PDF:', error);
    throw error;
  }
};

/**
 * Emails the plan as a formatted message
 * @param plan - The plan record to email
 */
export const emailChecklist = (plan: PlanRecord): void => {
  if (!plan) throw new Error('No plan provided');
  
  // Process the plan data
  const stages = ['Identification', 'Definition', 'Delivery', 'Closure'];
  const parentsByStage = getParentsByStage(plan.id);
  
  // Create email body
  let subject = 'TCOF Project Checklist';
  let body = 'TCOF Project Checklist\n\n';
  body += `Generated: ${new Date().toLocaleString()}\n\n`;
  
  stages.forEach(stageStr => {
    const stage = stageStr as Stage;
    body += `=== ${stage} ===\n\n`;
    
    if (parentsByStage[stage] && parentsByStage[stage].length > 0) {
      parentsByStage[stage].forEach((parent: any) => {
        if (parent.tasks && parent.tasks.length > 0) {
          body += `${parent.label}:\n`;
          
          parent.tasks.forEach((task: string) => {
            body += `[ ] ${formatTaskName(task)}\n`;
          });
          
          body += '\n';
        }
      });
    } else {
      body += 'No tasks for this stage\n\n';
    }
  });
  
  body += '\n\nGenerated by The Connected Outcomes Framework Toolkit';
  
  // Open email client
  const mailtoUrl = `mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
  window.open(mailtoUrl, '_self');
};